#+INCLUDE: "../../../common/header.org"
#+TITLE: PLSQL

#+latex_header: \lstset{emph={begin,declare,serveroutput,trigger,on,before,after,each, if, elsif, exit, while, loop}, emphstyle=\color{Blue}\ttfamily\bfseries}
#+reveal_single_file: nil



* Introducción
- PLSQL es un lenguaje de programación ejecutado en los servidores Oracle
  - Con acceso a todas las sentencias SQL
  - Incluye variables, funciones, control de flujo...


** Palabras reservadas
- Vista =V$RESERVED_WORDS=
- Definen estructuras de programa
- No pueden ser usados como identificadores

** Identificadores
- Nombres definidos por el programador
  - No puede ser una palabra reservada
  - Constante, variable, excepción, paquete, función, procedimiento, tabla, cursor...
  - Hasta 30 caracteres
  - Comienza por una letra. 
  - Puede contener =$=, =#=, pero no puede contener operadores =+­%=/*= 

* Bloques anónimos

#+caption: Bloque anónimo
#+begin_src sql

select * from pepe where nombre='a';
SET SERVEROUTPUT ON;

begin
  dbms_output.put_line('Hola');
END;
/

#+end_src

* Variables
- Valores referenciados por un identificador
- Deben declararse al principio de los bloques

#+begin_src sql
SET SERVEROUTPUT ON;

DECLARE
  msg varchar(255);
BEGIN
  msg := 'Hola';
  dbms_output.put_line(msg);
END;
/
#+end_src

** Tipos de variable
- Se pueden utilizar todos los tipos SQL
  - =char=, =varchar=
  - =number=, =integer=, =float=
  - =date=, =timestamp=
  - =blob=, =clob=
- Tipos propios de PLSQL
  - =bool=
  - =pls_integer=

** Tipos referidos
- =%type= : Tipo de un campo de una tabla
- =%rowtype= : Tipo compuesto, referido a una fila de una tabla


#+begin_src sql
create table cliente( id integer, nombre varchar(255) );

DECLARE
  filacliente cliente%rowtype;
BEGIN
  filacliente.id := 1;
  filacliente.nombre := 'María';
  insert into cliente values filacliente;
END;
/
#+end_src

* Control de flujo

** Condicional
#+begin_src sql
DECLARE
  numero integer := 1;
BEGIN
  if( numero < 0 ) then
    dbms_output.put_line( "Menor que cero");
  elsif( numero > 0 ) then
    dbms_output.put_line( "Mayor que cero");
  else
    dbms_output.put_line( "Igual que cero");
  end if;
END;
/
#+end_src

** Condicional múltiple (I)

#+begin_src sql oracle
case
  when vsalario<0 then
    dbms_output.put_line('Incorrecto');
  when vsalario=0 THEN
    dbms_output.put_line('Gratis!');  
  when vsalario<10000 then
    dbms_output.put_line('Salado!');
  when vsalario<90000 then
    dbms_output.put_line('Mas o menos');
  else
    dbms_output.put_line('Correcto');
end case;
#+end_src

** Condicional múltiple (II)
#+begin_src sql
case v_job_grade
  when 1 THEN
    dbms_output.put_line('Jefe!');
  when 2 then
    dbms_output.put_line('Jefecito');
  when 3 then
    dbms_output.put_line('Empleado regular');
  ELSE
    dbms_output.put_line('CEO');
end case;
#+end_src

** Bucle =loop=
#+BEGIN_SRC sql
LOOP
    -- Instrucciones
    IF (expresion) THEN
      -- Instrucciones
      EXIT;
    END IF;
END LOOP;
#+END_SRC

** Bucle =while=
#+BEGIN_SRC sql
WHILE (expresion) LOOP
    -- Instrucciones
END LOOP;
#+END_SRC

** Bucle =for=
#+BEGIN_SRC sql
DECLARE
  c PLS_INTEGER DEFAULT 0;
BEGIN
  FOR c IN REVERSE 1..10 LOOP
    dbms_output.put_line ('Contador = '||c);
  END LOOP;
END;
#+END_SRC

* Sentencias SQL en PLSQL

** Variables en =select=

#+BEGIN_SRC sql
create table empleados( empno number(20), salario number(8,2), nombre varchar(255));
DECLARE
  vsalario NUMBER;
BEGIN
  SELECT salario INTO vsalario FROM empleados WHERE empno=7369;
  dbms_output.put_line('El empleado numero 7369 tiene un vsalario de '||vsalario||'€');
end;
/
#+END_SRC

** Variables en =insert=, =update=, =delete=
- Se utilizan como un valor inmediato
#+BEGIN_SRC sql
declare
  vempno number;
begin
  vempno := 100;
  insert into empleados(empno, salario, nombre)
         values( vempno, 1000, 'Juan');
  update empleados 
         set salario = salario + 100
         where empno = vempno;
  delete from empleados where empno = vempno;
end;
/
#+END_SRC

** Recorrer consultas
#+BEGIN_SRC sql
DECLARE
  c empleados%ROWTYPE;
  salariototal number;
  numeroempleados number;
  mediasalario number;
begin
  numeroempleados := 0;
  for c in (select * from empleados) loop
    dbms_output.put_line(c.nombre);
    numeroempleados := numeroempleados + 1;
    salariototal := salariototal + c.salario;
  end loop;
  mediasalario := salariototal / numeroempleados;
end;
/
#+END_SRC

* Funciones y procedimientos
- Son bloques de código identificados con un nombre
- Pueden invocarse desde otros bloques de código
- En la invocación, se utilizan parámetros
  - De entrada
  - De salida

** Funciones
- Las funciones devuelven *siempre* un valor
- Pueden recibir parámetros
- Por convenio:
  - El resultado de una función solo depende de sus parámetros
  - Una función no cambia la base de datos

#+BEGIN_SRC sql
CREATE OR REPLACE FUNCTION es_par(numero IN number)
RETURN boolean
IS
  resto number;
BEGIN
  resto := mod(numero,2);
  if( resto = 0 ) then
    return true;
  else
    return false;
  end if;
END;
/
#+END_SRC 

*** Funciones en SQL
- Una función puede utilizarse en SQL
#+BEGIN_SRC sql
select empno, es_par(empno) from empleados;
#+END_SRC

*** Funciones predefinidas
| replace | sysdate   | lpad   | instr  |
| substr  | nvl       | trim   | trunc  |
| upper   | to_date   | mod    | length |
| lower   | to_char   | decode |        |
| rpad    | to_number |        |        |

               

** Procedimientos
- Los procedimentos no devuelven un valor
  - Pero pueden tener parámetros =out=
#+BEGIN_SRC sql
CREATE OR REPLACE PROCEDURE aumenta_salario(vempno IN number)
IS
BEGIN
  update empleados 
    set salario=salario+100
    where empno = vempno;
END;
/
#+END_SRC 

** Parámetros =in=
- Es el tipo de parámetros por defecto
- Un parámetro =in= se pasa /por valor/
- Se copia el valor introducido en el parámetro 
- Un cambio del parámetro no afecta al bloque llamante

#+begin_src sql
create or replace procedure suma_uno(n in numeric) is
begin
  n := n +1;
end;
/

declare
  numero numeric(10,0);
begin
  numero := 3;
  sumauno(numero);
  dbms_output.put_line(numero);
end;
/
#+end_src


** Parámetros =out=
- Un parámetro =out= se pasa /por referencia/
- Un cambio del parámetro afecta al bloque llamante

#+begin_src sql
create or replace procedure suma_uno(n in out numeric) is
begin
  n := n +1;
end;
/

declare
  numero numeric(10,0);
begin
  numero := 3;
  sumauno(numero);
  dbms_output.put_line(numero);
end;
/
#+end_src



* Control de errores
- Si se produce un error, se lanza una *excepción*
  - Se interrumpe el flujo de programa
  - Hasta que se *atrapa*
  - Puede atraparse en cada bloque/funcion/procedimiento

#+BEGIN_SRC sql
DECLARE
  -- Declaraciones
BEGIN
  -- Ejecucion
EXCEPTION
  -- Excepcion
END;
#+END_SRC

** Sección /exception/
- Se especifican varios tipos de excepción que se esperan
#+BEGIN_SRC sql
DECLARE
  -- Declaraciones
BEGIN
  -- Ejecucion
EXCEPTION
  WHEN NO_DATA_FOUND THEN 
    -- Se ejecuta cuando ocurre una excepcion de tipo NO_DATA_FOUND
  WHEN ZERO_DIVIDE THEN
    -- Se ejecuta cuando ocurre una excepcion de tipo ZERO_DIVIDE
  WHEN OTHERS THEN
    -- Se ejecuta cuando ocurre una excepcion de un tipo no tratado
    -- en los bloques anteriores
END;
#+END_SRC

** Excepciones predefinidas
- Estas son algunas (hay muchas)
| NO_DATA_FOUND    | TOO_MANY_ROWS | ACCESS_INTO_NULL |
| INVALID_NUMBER   | NO_DATA_FOUND | VALUE_ERROR      |
| ROWTYPE_MISMATCH | ZERO_DIVIDE   |                  |


** =SQLCODE= y =SQLERRM=   
- Funciones predefinidas
- =SQLCODE=: Número de error (independiente del idioma)
- =SQLERRM=: 
  - Sin parámetros: Mensaje de error en el idioma de la base de datos
  - Con un parámetro: mensaje de ese =sqlcode=

#+BEGIN_SRC sql
DECLARE
  result NUMBER;
BEGIN
  SELECT 1/0 INTO result FROM DUAL;
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.put_line('Error:'||TO_CHAR(SQLCODE));
    DBMS_OUTPUT.put_line(SQLERRM);
END;
#+END_SRC





** Excepciones de usuario
- En ocasiones queremos enviar un mensaje de error personalizado
- Están disponibles los números de error entre =­20001= y =­20999=
- Se pueden atrapar con =when others= y comprobarse con =SQLCODE=

#+BEGIN_SRC sql
  DECLARE
    n number;
  BEGIN
    SELECT count(*) into n from empleados
    if( n < 10 ) then
      RAISE_APPLICATION_ERROR(-20001,'La empresa necesita al menos 10 empleados');
    end if;
  EXCEPTION 
    WHEN OTHERS THEN
      if( sqlcode = -20001) then
        dbms_output.put_line('Pocos empleados');
      end if;
  END;
#+END_SRC

* [[https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_7004.htm][Disparadores]] (/triggers/)
- Las funciones y procedimientos se invocan desde /fuera/ de la base de datos
- Los disparadores los lanza la propia base de datos en respuesta a eventos
- Cada tabla tiene sus propios eventos
- Los disparadores se pueden lanzar /antes/ o /después/ del evento
- Los disparadores se pueden lanzar una vez por cada fila afectada, o una vez para toda la sentencia SQL

#+BEGIN_SRC sql
CREATE or replace TRIGGER personal_minimo
BEFORE DELETE ON empleados
declare
  n number;
begin
  SELECT count(*) into n from empleados;
  if( n < 10 ) then
    RAISE_APPLICATION_ERROR(-20001,'La empresa necesita al menos 10 empleados');
  end if;
end;
/
#+END_SRC

** Eventos
| Evento DML  |                                      |
|-------------+--------------------------------------|
| ~delete~    | Borrado de una fila                  |
| ~insert~    | Insercción de una fila               |
| ~update~    | Modificación de fila                 |
| ~update of~ | Modificación de un campo de una fila |

#+reveal: split

| Evento DDL/sistema      |                         |
|-------------------------+-------------------------|
| ALTER                   | Modificación de objetos |
| ANALYSE                 |                         |
| ASSOCIATE STATISTICS    |                         |
| AUDIT                   |                         |
| COMMENT                 |                         |
| CREATE                  | Creación de objetos     |
| DDL                     |                         |
| DISASSOCIATE STATISTICS |                         |
| DROP                    | Borrado de Objetos      |
| GRANT                   |                         |
| LOGON                   |                         |
| LOGOFF                  |                         |
| NOAUDIT                 |                         |
| RENAME                  |                         |
| REVOKE                  |                         |
| TRUNCATE                |                         |
| SERVERERROR             |                         |
| STARTUP                 |                         |
| SHUTDOWN                |                         |
| SUSPEND                 |                         |

- Se pueden combinar para un mismo /trigger/
  - Las funciones =INSERTING=, =UPDATING= y =DELETING= sirven para diferenciar por qué se ha lanzado

#+reveal: split
#+BEGIN_SRC sql
CREATE or replace TRIGGER ejemplo_or
BEFORE DELETE OR UPDATE OR INSERT ON empleados
begin
  case 
    when inserting THEN
      dbms_output.put_line('Insertando empleados');
    when updating then
      dbms_output.put_line('Actualizando empleados');
    when deleting then
      dbms_output.put_line('Borrando empleados');
    else
      dbms_output.put_line('Inesperado');
  end case;
end;
/
#+END_SRC

** =for each row=
- Por defecto, un /trigger/ se lanza una vez por cada sentencia SQL que provoque cambios
- Si se especifica =for each row=, se lanza una vez por cada fila cambiada

** Momentos del evento
- Se puede lanzar
  - =before=
  - =after=
  - =instead of=: No se ejecuta el SQL, sino otro alternativo. Útil para vistas modificables.
- Las variables =:old= y =:new= existen en los /triggers/ tipo =for each row=
  - =:old=: Variable tipo =%rowtype= con los datos antiguos de la fila
  - =:new=: Datos nuevos de la fila

| Momento  | Evento   | =:old=  | =:new=            |
|----------+----------+---------+-------------------|
| ~before~ | ~delete~ | Lectura |                   |
| ~before~ | ~insert~ |         | Lectura/escritura |
| ~before~ | ~update~ | Lectura | Lectura/escritura |
| ~after~  | ~delete~ | Lectura |                   |
| ~after~  | ~insert~ |         | Lectura           |
| ~after~  | ~update~ | Lectura | Lectura           |



** Ejemplo típico: auditoría
#+BEGIN_SRC sql
alter table empleados add (
  createdby varchar(255),
  createddate timestamp,
  modifiedby varchar(255),
  modifieddate timestamp 
);
#+END_SRC

#+BEGIN_SRC sql
create or replace trigger auditoria_creacion_empleados
  before insert 
  on empleados
  for each row
begin
  :new.createdby := username;
  :new.createddate := systimestamp;
end;
/
#+END_SRC



** Sintaxis (casi) completa
#+BEGIN_SRC sql
CREATE [OR REPLACE] TRIGGER <nombre_trigger>
  {BEFORE|AFTER}
  {DELETE|INSERT|UPDATE [OF col1, col2, ..., colN]
  [OR {DELETE|INSERT|UPDATE [OF col1, col2, ..., colN]...]}
  ON <nombre_tabla>
  [FOR EACH ROW [WHEN (<condicion>)]]
DECLARE
  -- variables locales
BEGIN
  -- Sentencias
[EXCEPTION]
  -- Sentencias control de excepcion
END;
#+END_SRC

* Referencias
- Formatos:
  - [[file:gbd-6-plsql.reveal.html][Transparencias]]
  - [[file:gbd-6-plsql.pdf][PDF]]
- Creado con:
  - [[https://www.gnu.org/s/emacs/][Emacs]]
  - [[https://github.com/yjwen/org-reveal][org-reveal]]
  - [[https://www.latex-project.org/][Latex]]
