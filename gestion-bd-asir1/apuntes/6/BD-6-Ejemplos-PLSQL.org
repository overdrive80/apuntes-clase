#+title: Ejemplos y ejercicios PLSQL
* Programación

** Tabla de multiplicar Del 7
#+begin_src c
7 x 1 = 7
7 x 2 = 14
...
#+end_src
** Tablas de multiplicar del 1 al 9
** Tablas de multiplicar bien alineadas
Los números se tabulan alineándolos a la derecha
#+begin_src c
7 x  1 =  7
7 x  2 = 14
7 x  3 = 14
7 x  4 = 14
7 x  5 = 14
7 x  6 = 14
7 x  7 = 14
7 x  8 = 14
7 x  9 = 14
7 x 10 = 14
#+end_src
** Pasar de decimal a binario
** Pasar de decimal a una base entre 2 y 16
** Pasar de una base de 2 a 16 a decimal 
** Números primos menores de 1000
** Decidir si un número es capicúa
Usa =to_char= para pasar el número a texto, y utiliza =substr= para extraer posiciones del texto y compararlas.
** Números primos capicúas menores de 100000

** Decidir si 1000003 es primo

*** Solución                                                       :noexport:
#+begin_src sql
declare
  posibleprimo numeric(10,0) := 1000003;
  limitededivisores numeric(10,0);
  esprimo boolean := true;
begin
  limitededivisores := sqrt(posibleprimo)+1;
  for posibledivisor in 2..limitededivisores loop
     esprimo := mod(posibleprimo,posibledivisor) <> 0;
     exit when not esprimo;
     
  end loop;
  if( esprimo ) then
    dbms_output.put_line( posibleprimo || ' es primo'  );
  else
    dbms_output.put_line( posibleprimo || ' NO es primo'  );
  end if;
end;
/
#+end_src


** Convertir boolean a char

*** Solución                                                       :noexport:
#+begin_src sql
create or replace function bool2char(b in boolean) return varchar 
is
begin
  return (case b when true then 'si' else 'no' end );

end;
/
#+end_src


** Primos

*** Solución                                                       :noexport:
#+begin_src sql
create or replace function es_primo(posibleprimo IN number) return char
is
  esprimo boolean := true;
begin
  for posibledivisor in 2..(sqrt(posibleprimo)) loop
     esprimo := mod(posibleprimo,posibledivisor) <> 0;
     exit when not esprimo;
  end loop;
  return case esprimo
    when true then 's'
    else 'n' 
  end;  
end;
/
#+end_src

#+begin_src sql
begin
  for i in 2 .. 1000 loop
    if( es_primo(i) = 's' ) then
      dbms_output.put_line( 'Es primo:' || i );
    end if;
  end loop;
end;
/
#+end_src


** Paso por valor

*** Solución                                                       :noexport:
#+begin_src sql
create or replace procedure sumaUno(n in out numeric)
is
begin
  n := n +1;
end;
/

declare
  numero numeric(10,0);
begin
  numero := 3;
  sumauno(3);
  dbms_output.put_line(numero);
end;
/

#+end_src






* Estudiantes

** Estadística por nombre
Crea un procedimiento que reciba un nombre o apellido, e imprima cuántos alumnos tienen ese nombre o apellido.
*** Solución                                                       :noexport:
#+begin_src sql
create or replace function cuantos_se_llaman(nombre_o_apellidos in varchar) return numeric
as
  cuantosnombres numeric;
  cuantosapellidos numeric;

begin
  select count(*) 
     into cuantosnombres 
     from student 
     where first_name = nombre_o_apellidos;
  
  select count(*) 
     into cuantosapellidos 
     from student 
     where last_name = nombre_o_apellidos;
  
  return cuantosnombres + cuantosapellidos;

end;
/

begin
  dbms_output.put_line( cuantos_se_llaman('González') );
end;
/
#+end_src


** Matricular un hermano
 Un hermano comparte todos los datos, excepto el nombre y el tratamiento

*** Solución                                                       :noexport:
 #+begin_src sql
 create or replace 
 PROCEDURE MATRICULAR_HERMANO(student_id_existente number, saludo_hermano varchar, nombre_hermano varchar) AS 
   alumno_existente student%ROWTYPE;
 BEGIN
   select * into alumno_existente from student where student_id = student_id_existente;
  
   select max(student_id)+1 into alumno_existente.student_id from student;

   alumno_existente.salutation := saludo_hermano;  
   alumno_existente.first_name := nombre_hermano;
  
   insert into student values alumno_existente;
  
 END MATRICULAR_HERMANO;
 #+end_src

** Calcular nota máxima y mínima
Crea una función con dos parámetros out, que devuelvan la nota mínima y máxima entre las notas parciales (tabla =grade=)

*** Solución                                                       :noexport:
#+begin_src sql
create or replace function maxima_minima_nota(
  maximo out numeric,
  minimo out numeric
)
return varchar
as
  retorno varchar(15) := 'sin datos';
begin
  maximo := -1000;
  minimo := 1000;
  for g in (select * from grade) loop
    retorno := 'ok';
    maximo := greatest(maximo,g.numeric_grade);
    minimo := least(minimo,g.numeric_grade);
  end loop;
  return retorno;
end;
/
#+end_src

** Calcular la media de notas por encima de cierto valor
Crea una función que devuelva la media de las notas mayores que un umbral (tabla =grade=)
*** Solución                                                       :noexport:
 #+begin_src sql
 create or replace 
 FUNCTION MEDIA_DE_GRADES(minimo number) RETURN number AS 
   total number;
   numero number;
 BEGIN
   total := 0;
   numero := 0;
   for g in (select numeric_grade from grade) 
   loop
     if g.numeric_grade > minimo then
       total := total + g.numeric_grade;
       numero := numero + 1;
     end if;
   end loop;
  
   return total/numero;
  
 END MEDIA_DE_GRADES;
 #+end_src

** Costes totales de los cursos
Funcion que devuelve la suma de los precios de todos los cursos (table =course=)

*** Solución                                                       :noexport:
 #+begin_src sql
 create or replace 
 FUNCTION SUMACOSTES RETURN NUMBER AS 
   CURSOR c_courses is select cost, course_no from course;
   resultado number;
   coste number;
   numerocurso number;
 BEGIN
   resultado := 0;
   open c_courses;
  
   fetch c_courses into coste, numerocurso;
   while not c_courses%NOTFOUND LOOP
     if coste is not null then
       resultado := resultado + coste;
     else
       SYS.dbms_output.put_line( 'Es null:' || numerocurso );
     end if;
     fetch c_courses into coste, numerocurso;
   end loop;
  
   close c_courses;
   return resultado;
 END;
 #+end_src

** Insertar un ID automático en un estudiante

Crea un /trigger/ que añada un ID a los estudiantes insertados, en el caso de que no tengan un ID ya asignado. El ID saldrá de una secuencia.
*** Solución                                                       :noexport:
 #+begin_src sql
 CREATE OR REPLACE TRIGGER "ALUMNO"."PONER_ID_A_STUDENT" 
    before insert on "ALUMNO"."STUDENT" 
    for each row 
 begin  
    if inserting then 
       if :NEW."STUDENT_ID" is null then 
          select STUDENT_ID_SEQ.nextval into :NEW."STUDENT_ID" from dual; 
       end if; 
    end if; 
 end;
 ALTER TRIGGER "ALUMNO"."PONER_ID_A_STUDENT" ENABLE;
 #+end_src

** Actualizar campos de auditoría

Crea  /triggers/ que actualicen los campos de auditoría =modified_by= y =modified_date= de todas las tablas de la base de datos.
*** Solución                                                       :noexport:
#+begin_src sql
create or replace trigger actualiza_lo_de_modificado
before update
on student
for each row
begin
  :new.modified_by := user;
  :new.modified_date := sysdate;
end;
/
#+end_src

* Sueldos y masa salarial (desnormalización)

** Tablas de masa salarial

#+begin_src sql
create table sueldos( sueldo numeric)
create table masasalarialtotal(id integer, total numeric);
#+end_src

** Limitar los sueldos por arriba y por abajo
haz un /trigger/ que evite que asegure que los empleados no cobran menos de 100000€ ni más de 1000000€.


*** Solución                                                       :noexport:
#+begin_src sql
CREATE TRIGGER COMPROBAR_SUELDO
BEFORE
INSERT OR UPDATE OF sueldo ON sueldos
FOR EACH ROW
DECLARE
SUELDO_FUERA_RANGO EXCEPTION;
BEGIN
IF (:NEW.sueldo < 100000 OR
:NEW.sueldo > 1000000) THEN
RAISE SUELDO_FUERA_RANGO;
END IF;
END;
#+end_src


** Inicializar la masa salarial
Crea una tabla =masasalarialtotal=. Tendrá una sola fila con la suma de todos los sueldos

#+BEGIN_SRC sql
create table masasalarialtotal( total numeric );
#+END_SRC

Crea un procedimiento que se asegure que solo hay una fila con la suma de todos los sueldos.

*** Solución                                                       :noexport:
#+begin_src sql
CREATE OR REPLACE PROCEDURE INICIALIZA_MASA_SALARIAL_TOTAL AS 
  t number;
BEGIN
  select sum(sueldo) into t from sueldos;
  if t is null then
    t := 0;
  end if;
  update masasalarialtotal set total = t;
END INICIALIZA_MASA_SALARIAL_TOTAL;
#+end_src


** Actualizar al borrar
Crea un /trigger/ que actualice la masa salarial al borrar un sueldo
*** Solución                                                       :noexport:
#+begin_src sql
CREATE OR REPLACE TRIGGER MASA_SALARIAL_BORRANDO 
BEFORE DELETE ON SUELDOS 
FOR EACH ROW 
BEGIN
  UPDATE masasalarialtotal set total = total - :old.sueldo;
END; 
#+end_src



** Actualizar al modificar o insertar
Crea un /trigger/ que actualice la masa salarial al modificar o insertar un sueldo

*** Solución                                                       :noexport:
#+begin_src sql
CREATE OR REPLACE TRIGGER MENOR_DE_UN_MILLON 
BEFORE INSERT or update ON SUELDOS
for each row
declare
  masasalarial number;
  sueldo_fuera_de_rango exception;
BEGIN

  if inserting then
    masasalarial := masasalarial + :new.sueldo;
  end if;
  
  if updating then
    select total into masasalarial from masasalarialtotal where id=1;
    masasalarial := masasalarial - :old.sueldo + :new.sueldo;
  end if;
  
  if  masasalarial > 1000000  then
    raise  sueldo_fuera_de_rango;
  end if;
  
  update masasalarialtotal set total = masasalarial;
END;
#+end_src

