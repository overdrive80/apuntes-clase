#+INCLUDE: "../../../common/header.org"
#+TITLE:  Ethernet: LLC
#+SUBTITLE: 
#+KEYWORDS: 


* Introducción

** La capa de enlace
- Es la capa 2 de la arquitectura OSI.
- Se encarga de conseguir que la comunicación de datos se produzca correctamente a través de un medio físico de transmisión.
- Para lograr que dos dispositivos adyacentes se comuniquen, se necesita un control del intercambio de datos: el control del enlace.
- La capa de enlace proporciona a la capa de Red un servicio de transporte de bits fiable (asegura que los bit se trasmiten correctamente por el medio físico).
- El bloque de datos transmitido se denomina TRAMA.

** Funciones de la capa de enlace
- Sincronización a nivel de trama.
- Control de flujo: las estaciones deben ponerse de acuerdo en el ritmo de trasmisión de datos.
- Control de errores: los enlaces no son perfectos. Hay que controlar que no haya errores en la transmisión.
- Direccionamiento: si hay varios posibles destinos, es necesario identificar a quien va dirigida la trama.
- Gestión del enlace:
  - Inicio de la transmisión
  - Mantenimiento de la transmisión
  - Finalización de la transmisión


** MAC y LLC
- En la arquitectura IEE 802, el nivel de enlace se divide en dos subcapas:
  - LLC: se encarga de las funciones comunes de la capa independientemente del medio físico usado 
    - Control de errores
    - Direccionamiento
    - Sus funciones han sido definidas por el subgrupo 802.2.
  - MAC: se encarga del acceso al medio (gestión del enlace)



* Tramas
- Una trama es un bloque de bits agrupados que son enviados por la línea.
- El tamaño de la trama depende del tipo de red.
- Agrupar los bits en tramas facilita:
  - la detección y corrección de errores 
  - la compartición del medio.
- Una trama se compone de tres partes
  - Información sobre la trama
  - Datos.
  - Redundacia.


* Control de errores
- Consiste en enviar algunos bits añadidos a los datos con información que permita detectar o corregir los errores.
- El porcentaje de redundancia se calcula como 
  $$\frac{Número de bits de control}{bits totales}\times 100$$
- Los errores pueden
  - Detectarse
  - Adicionalmente, corregirse


** Detección de errores
- ECO. El receptor envía una copia exacta de la información recibida al emisor.
- Paridad lineal. Se añade un bit extra, indicando si el número de bits con valor a 1 es par o impar.
  - =100100=, con paridad par, se envía como =100100= *=0=*
  - =100100=, con paridad impar, se envía como =100100= *=1=*

*** Paridad de bloque
- Paridad de bloque. Se distribuyen los datos en una tabla y se calcula paridad por cada línea y columna.
  - Mensaje: =1100101= =0110110= =1011010= =1001111= =0111001= =1100111= =1010000=, con paridad par
  - Se envía =1100101= *=0=* =0110110= *=0=* =1011010= *=0=* =1001111= *=1=* =0111001= *=0=* =1100111= *=1=* =1010000= *=0=* *=1001000=* *=0=*
#+reveal: split
   |                   |   Datos | Paridad lineal |
   |-------------------+---------+----------------|
   |                   | 1100101 |              0 |
   |                   | 0110110 |              0 |
   |                   | 1011010 |              0 |
   |                   | 1001111 |              1 |
   |                   | 0111001 |              0 |
   |                   | 1100111 |              1 |
   |                   | 1010000 |              0 |
   | Paridad de bloque | 1001000 |              0 |

  
** Actividad
- Calcular la paridad bidimensional del siguiente mensaje:
  - =1001101, 1111010, 1100110, 1110001, 1101001, 1110111, 0010111=


** [[https://es.wikipedia.org/wiki/Verificaci%25C3%25B3n_de_redundancia_c%25C3%25ADclica][CRC]]
- Al principio de la comunicación, emisor y receptor acuerdan un Polinomio Generador.
- Al iniciar la transmisión se añaden un número predeterminado de ceros a la información a enviar y se divide utilizando el polinomio generador.
- El receptor realiza nuevamente una división sobre los datos recibidos y si el resto es 0 indica que la trama se ha recibido sin errores.
- Finalmente se descartan los bits añadidos en el transmisor para quedarnos con el mensaje original.


*** ¿Por qué CRC?
- Hay versiones de CRC para diferentes longitudes de polinomio: CRC16, CRC32,...
- Los errores se producen típicamente a ráfagas
- Para un CRC de $n$ bits
  - Se detectan todos los errores de ráfagas de menos de $n$ bits incorrectos
  - Se detecta una fracción de las ráfagas más largas ($1 − 2^{-n}$)

| Longitud de crc | Porcentaje de detección de ráfagas mayores |
|-----------------+--------------------------------------------|
|               8 |                                  99.609375 |
|              16 |                                  99.998474 |
|              32 |                           99,9999999767169 |
#+TBLFM: @2$2=100-100*2^(-@2$1)::@3$2=100-100*2^(-@3$1)

* Corrección de errores
- La detección de errores es el primer paso
- Una vez detectado:
  - Se puede ignorar (las capas más altas deben arreglar el error)
  - Se puede corregir
- Ethernet no corrige errores, pero veremos algunas técnicas que pueden usar otras capas 2

** Retransmisión
- Es el método de corrección más sencillo.
- Se detecta el error y se pide al emisor que vuelva a enviar la trama.
- Se tienen que memorizar las tramas enviadas hasta la recepción de un ACK que confirme que el envío de información fue exitosa.



Corrección de errores – Código Hamming. Ejemplo 7-4
El código Hamming permite detectar y corregir errores en el
equipo receptor.
En función del número de bits redundantes podrán corregirse
mayor número de errores. Para el ejemplo aquí mostrado, sólo es
posible corregir un error en cada grupo de cuatro bits enviados.
Para conseguirlo debemos incluir tres bits extra.



Corrección de errores – Código Hamming. Ejemplo 7-4
OPERACIONES EN EL EMISOR
Consideraremos el envío del mensaje 1 0 1 1 (a3 a2 a1 a0 )
Cálculo de los bits extra a enviar:
s0 = (a0 + a1 + a2) mod 2 => (1 + 1 + 0) mod 2 = 0
s1 = (a1 + a2 + a3) mod 2 => (1 + 0 + 1) mod 2 = 0
s2 = (a0 + a1 + a3) mod 2 => (1 + 1 + 1) mod 2 = 1
Mensaje enviado:
a3 a2 a1 a0 s2 s1 s0 => 1 0 1 1 1 0 0



Corrección de errores – Código Hamming. Ejemplo 7-4
OPERACIONES EN EL RECEPTOR
Mensaje recibido sin errores. Tiene 7 bits y corresponde
exactamente con los bits que se enviaron:
a3 a2 a1 a0 s2 s1 s0 => 1 0 1 1 1 0 0 (si la recepción es correcta)
Cálculo de los bits de comprobación:
r0 = (a0 + a1 + a2 + s0) mod 2 => (1 + 1 + 0 + 0) mod 2 = 0
r1 = (a1 + a2 + a3 + s1) mod 2 => (1 + 0 + 1 + 0) mod 2 = 0
r2 = (a0 + a1 + a3 + s2) mod 2 => (1 + 1 + 1 + 1) mod 2 = 0



Corrección de errores – Código Hamming. Ejemplo 7-4
OPERACIONES EN EL RECEPTOR
Mensaje recibido con error.:
a3 a2 a1 a0 s2 s1 s0 => 1 0 1 1 1 0 0 (dato enviado)
a3 a2 a1 a0 s2 s1 s0 => 1 0 0 1 1 0 0 (dato recibido con error en
a1)
Cálculo de los bits de comprobación:
r0 = (a0 + a1 + a2 + s0) mod 2 => (1 + 0 + 0 + 0) mod 2 = 1
r1 = (a1 + a2 + a3 + s1) mod 2 => (0 + 0 + 1 + 0) mod 2 = 1
r2 = (a0 + a1 + a3 + s2) mod 2 => (1 + 0 + 1 + 1) mod 2 = 1
r2 r1 r0 => 111. Mirando la tabla se ve que el error esta en a1



Actividades
Utilizando el código Hamming 7-4 para el mensaje 1000 (d3 d2 d1
d0):
Determina, justificando tus respuestas:
Bits extra enviados en el emisor
Mensaje enviado.
Bits de comprobación si todo el mensaje se ha recibido
correctamente.
Bits de comprobación si en larecepción se ha producido un error en
el bit d0.



